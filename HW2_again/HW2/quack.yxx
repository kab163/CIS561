/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
    // block needs a more explicit type to use the 'append' method
    AST::Block* block;
}

// The following token values are actually used
%token <str> IDENT STRING_LIT
%token <num> INT_LIT
// The following tokens don't need values
%token CLASS DEF EXTENDS WHILE RETURN
%token EQUALS ATMOST ATLEAST
%token TYPECASE AND OR NOT IF ELIF ELSE

// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
%left '-' '+'
%left '*' '/'

%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: classes stmts { }
       ;

/* Standard recursive definition for a non-empty sequence. */
classes: %empty { } 
     |classes class { }
     ;

class: CLASS IDENT '(' stmts ')' '{' stmts '}' { }
     | CLASS IDENT '(' stmts ')' EXTENDS IDENT '{' stmts '}' { } 
     ;

stmts: %empty { }
     | stmts stmt { }
     ;

stmt: %empty { }
     | ifstmt { }
     | while_stmt { }
     | meth_stmt { }
     | return { }
     | typeC { }
     | L_Expr ':' IDENT ',' { }
     | L_Expr ':' IDENT { }     
     | L_Expr ':' IDENT '=' R_Expr stmt { } 
     | L_Expr '=' R_Expr stmt { }
     | R_Expr { }
     ;

return: RETURN ';' { }
     | RETURN R_Expr stmt { }
     | RETURN L_Expr ';' { }
     ;

ifstmt: IF R_Expr '{' stmts '}' ELIF R_Expr '{' stmts '}' ELSE '{' stmts '}' { }
      | IF R_Expr '{' stmts '}' ELSE '{' stmts '}' { }
      | IF R_Expr '{' stmts '}' { }
      ;     

while_stmt: WHILE R_Expr '{' stmts '}' { }
          ;

meth_stmt: DEF IDENT '(' stmts ')' '{' stmts '}' { }
         | DEF IDENT '(' stmts ')' ':' IDENT '{' stmts '}' { }
         ;

typeC: TYPECASE R_Expr '{' types '}' { }
     ;

types: %empty { }
     | types type { }
     ;

type: stmts { }
    ; 

L_Expr : IDENT  { }
       | IDENT ';' { }
       | R_Expr '.' IDENT { }
       ;

R_Expr : INT_LIT';' { }
       | INT_LIT { }
       | STRING_LIT';' { }
       | STRING_LIT { }
       | L_Expr { }
       | R_Expr '*' R_Expr  { }
       | R_Expr '+' R_Expr  { }
       | R_Expr '-' R_Expr  { }
       | R_Expr '/' R_Expr  { }
       | R_Expr '>' R_Expr { }
       | R_Expr '<' R_Expr { }
       | R_Expr ATMOST R_Expr { }
       | R_Expr ATLEAST R_Expr { }
       | R_Expr EQUALS R_Expr { }
       | R_Expr AND R_Expr { }
       | R_Expr OR R_Expr { }
       | R_Expr '.' IDENT '(' R_Expr ')' { }
       | R_Expr '.' IDENT '(' ')' ';' { }
       | R_Expr '.' IDENT '(' ')' { }
       | R_Expr '.' IDENT '(' R_Expr ')' ';' { }
       | IDENT '(' R_Expr ')' { }
       | IDENT '(' R_Expr ')' ';' { }
       | NOT R_Expr { }
       | R_Expr ',' R_Expr { }
       | R_Expr R_Expr { }
       | R_Expr 'n' ';' { }
       | '(' IDENT ')' { }
       | '(' R_Expr ')' ';' { }
       | '(' R_Expr ')' { }
       | IDENT '(' ')' ';' { } 
       ;

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
